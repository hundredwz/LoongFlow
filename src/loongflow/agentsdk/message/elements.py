#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
This file defines elements which is used in message
"""

import uuid
from abc import ABC, abstractmethod
from enum import Enum
from typing import Annotated, Any, Dict, List, Literal, TypeVar

from pydantic import BaseModel, Field


class MimeType(str, Enum):
    """Enumeration for common MIME types used in message parts."""

    TEXT_PLAIN = "text/plain"
    APPLICATION_JSON = "application/json"
    IMAGE_JPEG = "image/jpeg"
    IMAGE_PNG = "image/png"
    AUDIO_MPEG = "audio/mpeg"
    VIDEO_MP4 = "video/mp4"


class ToolStatus(str, Enum):
    """Enumeration for tool status used in message parts."""

    SUCCESS = "success"
    ERROR = "error"
    IN_PROGRESS = "in_progress"


class BaseElement(BaseModel, ABC):
    """base element, all element should inherit from BaseElement"""

    type: Literal["base"] = "base"

    @abstractmethod
    def get_content(self) -> Dict[str, Any]:
        """
        get content of element
        :return: content of the element, which will be used in llm or token counting
        """
        pass


class ContentElement(BaseElement):
    """message content, like text or an image."""

    type: Literal["content"] = "content"
    mime_type: MimeType | str = Field(
        default=MimeType.TEXT_PLAIN,
        description="The MIME type of the content, e.g., 'text/plain', 'image/jpeg'.",
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict, description="Additional metadata for the content."
    )
    data: Any = Field(..., description="The actual data payload.")

    def get_content(self) -> Dict[str, Any]:
        return {
            "type": self.type,
            "content": {"mime_type": self.mime_type, "data": self.data},
        }


class ToolCallElement(BaseElement):
    """Request to call a tool, generated by the agent."""

    type: Literal["tool_call", "function"] = "tool_call"
    call_id: uuid.UUID = Field(
        default_factory=uuid.uuid4,
        description="A unique ID for this tool call instance.",
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict, description="Additional metadata for tool call."
    )
    target: str = Field(
        ..., description="The name of the tool or function to be invoked."
    )
    arguments: Dict[str, Any] = Field(
        ..., description="The arguments required by the tool."
    )

    def get_content(self) -> Dict[str, Any]:
        return {
            "type": self.type,
            "content": {"target": self.target, "arguments": self.arguments},
        }


class ToolOutputElement(BaseElement):
    """Result obtained from executing a tool."""

    type: Literal["tool_output"] = "tool_output"
    call_id: uuid.UUID = Field(
        ..., description="The ID of the corresponding ToolCallElement."
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict, description="Additional metadata for tool outputs."
    )
    tool_name: str = Field(..., description="The name of the tool.")
    status: ToolStatus = Field(..., description="Execution status of the tool call.")
    result: List[ContentElement] = Field(
        ...,
        description="The output of the tool, "
        "encapsulated as a list of ContentElements.",
    )

    def get_content(self) -> Dict[str, Any]:
        return {
            "type": self.type,
            "content": {
                "status": self.status,
                "result": [elem.get_content() for elem in self.result],
            },
        }


class ThinkElement(BaseElement):
    """
    Represents an internal thought or reasoning step of the Agent.
    """

    type: Literal["think"] = "think"
    metadata: Dict[str, Any] = Field(
        default_factory=dict, description="Additional metadata for model thoughts."
    )
    content: Any = Field(..., description="The content of the agent's thought.")

    def get_content(self) -> Dict[str, Any]:
        return {
            "type": self.type,
            "content": {"content": self.content},
        }


class EvolveResultElement(BaseElement):
    """
    Represents the result of an evolution process.
    """

    type: Literal["evolve_result"] = "evolve_result"
    best_score: float = Field(
        ..., description="The best score achieved in the evolution process."
    )
    best_solution: str = Field(
        ..., description="The best solution found in the evolution process."
    )
    evaluation: str = Field(
        ..., description="The evaluation details of the best_solution."
    )
    start_time: str = Field(..., description="The start time of the evolution process.")
    end_time: str = Field(..., description="The end time of finding the best solution.")
    cost_time: int = Field(
        ..., description="The total time cost of the evolution process."
    )
    last_iteration: int = Field(
        ..., description="The last iteration where the best solution was found."
    )
    total_iterations: int = Field(
        ..., description="The total number of iterations in the evolution process."
    )

    def get_content(self) -> Dict[str, Any]:
        return {
            "type": self.type,
            "content": {
                "best_score": self.best_score,
                "best_solution": self.best_solution,
                "evaluation": self.evaluation,
                "start_time": self.start_time,
                "end_time": self.end_time,
                "cost_time": self.cost_time,
                "last_iteration": self.last_iteration,
                "total_iteration": self.total_iterations,
            },
        }


ElementT = TypeVar("ElementT", bound="BaseElement")
Element = Annotated[
    ContentElement
    | ToolCallElement
    | ToolOutputElement
    | ThinkElement
    | EvolveResultElement,
    Field(discriminator="type"),
]
